# IOI23 Day 2
## Beech Tree
### Minimum (subtask 2 + maybe 1)
This was a hard problem, so much so that only 4 people had more than 31 points. Even just understanding the problem statement was hard. Interestingly, subtask 1 was one of the most straightforward of the whole IOI, from a purely algorithmic point of view. However, implementation wasn't easy. If $N \leq 8$ then there are at most 8 subtrees to test, each one requiring a permutation over at most 7 elements. So if we try every possible permutation for every vertex, this is $7!$ permutations per node, 8 nodes total, and testing if a permutation is beautiful takes $O(N)$ time.

Once you read the definition of beautiful permutation a couple of times and work through the example in the problem statement, you're ready to think about some of the subtasks. Subtask 2 should be pretty simple, since all of the test cases of this subtask correspond to line graphs. For a given $N$, the sequence of parents will look like $[-1, 0, 1, 2, ..., N-1]$, and all subtrees will have sequences that look like increasing sequences. So we conclude that given a certain subtree, the only way for it to be a beautiful subtree is if all of the vertices in that subtree are of the same color. One easy way of seeing that is that since all vertices have different parents, we need all $f(i)$ to be distinct, which can only happen if all of the colors are the same.

### Bronze (subtasks 2,3,4 + maybe 1)
To solve more subtasks, we need to find more properties of beautiful permutations. The first thing we can observe is that if two nodes have the same parent, then they have to have different colors, otherwise no subtree that includes both of them can be a beautiful subtree. The reason is simple: if they have the same parent, then the value of $f()$ associated to both vertices will have to be the same, but that can't be the case since if they have the same color then their values of $f()$ will have to differ by at least one (whichever vertex comes second in the permutation will have at least one more vertex of the same color). This gives us a way to solve the problem for any tree of height 1: all of the leaves are beautiful, the root is beautiful if the color of each vertex is distinct (the color of a vertex is the color of the edge from it to its parent). Subtask 3 concerns trees of height up to 2, so this isn't quite enough to solve that subtask. Note though that it helps us a lot, since the subtrees of a tree of height 2 are trees of height 0 or 1 except for the whole subtree (given by $T(0)$), so we only need to determine if $T(0)$ is beautiful for a tree of height 2 in order to solve this subtask.

Consider a tree of height 2 and let's try to determine if $T(0)$ is beautiful by trying to build a beautiful permutation. First note that the nodes at depth 1 (so the children of 0) will have to show up before any depth 2 nodes in the permutation. Intuitively this makes sense since we will need the children of depth 1 nodes to have values of f() that match their position in the permutation, so the earlier they come in the permutation the smaller $f()$ has to be. We can prove this by making a simple observation that for any $i$, $f(i)$ is at most the number of depth 1 nodes. This follows from the fact that the children of a node all have different colors, so there can only be `1 + |{nodes at depth 1}|` many nodes of a single color. So if the last depth 1 node comes after a depth 2 node, then its position in the permutation will be greater than `|{nodes at depth 1}|` and so its children can't have the correct $f()$. (sidenote: this isn't exactly true if there are depth 1 nodes with no children, but we can alter the argument slightly to account for this type of node). To complete the construction of a beautiful permutation we have to decide how to order the depth 1 nodes and how to order the depth 2 nodes. Intuitively, it makes sense to place depth 1 nodes with more children first and similarly place depth 2 nodes that are children of depth 1 nodes with more children first. Again we can prove that this intuition is correct by using the following observation. Suppose $v$ is a depth 2 node and its parent is the $a$th depth 1 node in the permutation. Then $v$ needs exactly $a$ other nodes of the same color as $v$ to precede it. Using the same argument we used in the previous observation, all of these $a$ nodes have to correspond to children of different depth 1 nodes plus one depth 1 node. We can now argue by contradiction that the only way for this condition to be met for all nodes is if nodes are sorted by number of children in the permutation order. Ties can be broken arbitrarily (if you write down the proof you should be able to see why).

So to recap, to solve subtask 3 we need to first determine if the colors of children of each node are all distinct (we can do this in $O(N \log N)$ by keeping a set per node). Nodes with distinct colored children are beautiful (except maybe 0). To determine if $0$ is beautiful, we form a permutation by first adding all children of 0 sorted by number of children, followed by all their children ordered in the same order as their parent. If this permutation is beautiful, then $0$ is beautiful, otherwise it isn't. We can perform this check in $O(N)$ time by simulating the process of computing all the $f()$s.

This solution also gives us basically all the tools needed to solve subtask 4. Note that if there are at most two edges of a certain color, then $f(i) \leq 1$ for any $i$. This implies that no subtree with height greater than 2 could be beautiful (it's even more constraining, the subtrees can only have one depth 1 node with children). So we can solve this subtask by checking if a subtree is of height 2 or less, if so run the solution from subtask 3, otherwise the node isn't beautiful. If you couldn't solve subtask 3, you could have solved this subtask by using the extra observation in parenthesis since it greatly simplifies the process of finding if the root of a height 2 tree is beautiful.

### Best (subtasks 1,2,3,4)
Solving the problem beyond subtask 4 implies more non-trivial observations and then some clever use of data structures.